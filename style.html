<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenCurves: Coding Style</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCurves
   &#160;<span id="projectnumber">0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('style.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Coding Style </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Thus his page documents the coding style guidelines.</p>
<p>In all cases, contributors are asked to adhere to the coding standard. Exhaustively defining a coding style is a difficult and potentially verbose undertaking. Thus this document focuses on guidelines. When in doubt, honour the existing style of the source file being edited.</p>
<p>While this document does not address all style issues, it does address common or important issues. For issues not covered by this document, please refer to the following additional material:</p><ul>
<li><a href="https://google.github.io/styleguide/cppguide.html">The Google C++ style guide.</a> This covers a more comprehensive list of issues and provides good justifications.</li>
<li><a href="https://wiki.qt.io/Qt_Coding_Style">The Qt style guide.</a> While this style guide differs slightly from the Qt style, there is a large amount of overlap.</li>
</ul>
<h1>Guideline Summary</h1>
<ul>
<li>Two space tabs.</li>
<li>Convert tabs to spaces.</li>
<li>Use forward declarations and limit includes.</li>
<li>Maintain const correctness.</li>
<li>Pointer and reference symbols align with the variable declaration.</li>
<li>Place spaces around arithmetic and logical operators.<ul>
<li>Removing whitespace to enhance precedence readability is excepted.</li>
</ul>
</li>
<li>Brackets have external spacing only when used with branching keywords.</li>
<li>Strive for zero compiler warnings.</li>
<li>Order includes (see below).</li>
<li>One class or structure per header file, nested types excepted.</li>
</ul>
<h1>Options for astyler</h1>
<p>It is recommended that contributors use <a href="http://astyle.sourceforge.net/">astyle</a> to aid in adhering to the coding standard formatting guidelines. </p><pre class="fragment">--style=allman
--indent=spaces=2
--min-conditional-indent=0
--max-instatement-indent=40
--align-pointer=name
--align-reference=name
--indent-cases
--indent-namespaces
--pad-oper
--pad-header
--unpad-paren
--add-brackets
--keep-one-line-blocks
--convert-tabs
--mode=c
</pre><h1>Compatibility Guidelines </h1>
<p>C++11 has now had time to mature and is well implemented across a variety of compilers. Most features are well supported and may be freely used. Some more less common or less important features are not so widely supported, such as <code>consexpr</code> and should still be avoided.</p>
<p>Cross platform development is fraught with pitfalls. Different compilers make different assumptions and adhere to standards differently. Different compilers generate different warnings, define different built in types and may differ in standard header organisation. Where possible, compile for at least two different platforms to promote improved compatibility. Visual Studio and G++ are good choices as these represent the most widely used compilers and have fairly disparate implementations.</p>
<h1>Formatting Guidelines </h1>
<p>Two space tabs, replace tabs with spaces* Use of real tab characters creates inconsistencies. Spaces are absolute and the alignment and indentation is invariant regardless of editor settings.</p>
<p>Place spaces around arithmetic and logical operators.* Whitespace around arithmetic and logical operators improved readability. One exception is where operational precedence may be lost in long arithmetic statements. That is, whitespace may be removed for highest precedence operations to better group those operations. Correct int i = a &lt;&lt; 1; int j = a + 2; float y = 2 * x + 1;</p>
<p>Incorrect float y=x+1;</p>
<p>Exception: multiplication precedence enhanced: float y = 2*x*x + 5*x + 1;</p>
<p>One variable declaration per line.* Correct int a; int b; int *intPtr; char *string;</p>
<p>Incorrect int a, b, *intptr; char *string;</p>
<p>Pointer and reference declarations are adjacent to the variable name.* Consider the following declaration: int* a, b; // Incorrect The declaration may be considered ambiguous as the pointer symbol is grouped with the type declaration, however, it only affects the first variable, <code>a</code>, and not the second, <code>b</code>. int *a, b; // Less incorrect The second declaration more concisely identifies the relationship between the pointer symbol and the affected variable. Note that it is still incorrect by this style guide, as each variable should be declared on a separate line.</p>
<p>Brackets have no leading or trailing whitespace for function definitions and calls.* Function definitions calls do not have whitespace around the brackets. Correct int fibonacci(int n); int i = fibonacci(5 * 3);</p>
<p>Incorrect int x = fibonacci( 10 ); int y = fibonacci (5);</p>
<p>Open brackets following branching statements have leading whitespace.* The open bracket '(' is preceded by a space when used with if, switch, for, while. Correct: for (int i = 0; i &lt; 10; ++i) ...</p>
<p>Incorrect if(x == 0) ... if( x == 0 ) ...</p>
<p>Scoping braces on separate lines.* Open and closing scoping braces appear on new, separate lines. The only exception is for single statement inline functions. Correct if (x == 0) { return true; } else if (x &gt; 0) { logWarning("..."); return true; } else { return false; }</p>
<p>Incorrect if (x == 0) { return true; } else if (x &gt; 0) { logWarning("..."); return true; } else { return false; }</p>
<p>Always use scoping brackets, even for single line content.* A common source of bugs comes from failing to scope single line if statements, then attempting to add instructions to the branch. This is easily avoided by always using scoping brackets, even for single line statements. Correct: if (x &gt; 0) { &ndash;x; }</p>
<p>Incorrect: if (x &gt; 0) &ndash;x;</p>
<p>Switch statements always have a <code>default</code> branch.* Always include a <code>default</code> branch for <code>switch</code> statements. Missing default branches can result in improperly handled situations (and bugs) as the possible switch values evolve during development. Some compilers rightly generate warnings about missing default cases.</p>
<p>Multi-line inline definitions belong outside the class definition.* Inline functions requiring more than a single statement are to be defined after the class definition. Only single statement inline functions belong in the class definition and the function implementation should appear on the same line as the function name.</p>
<p>The <code>inline</code> keyword appears with the function implementation.* This is relevant only for inline implementations appearing after the class definition. For such definitions, the <code>inline</code> keyword appears with the function implementation, not in with the function prototype. This is because the inline nature is an implementation detail and should not be relevant to the user. Correct: class A { public: ... inline float timeScale() const { return _timeScale; }</p>
<p>void setTimeScale(float scale); }</p>
<p>inline void A::setTimeScale(float scale) { if (scale) { _timeScale = scale; } else { _timeScale = 1.0f; } }</p>
<p>Member variables are private or protected, preferably private.* Member variables should generally be private, with public and protected accessor methods where required. Public members of simple or POD structure are acceptable.</p>
<p>Avoid assignment in conditional statements.* Avoid using assignment in if, and loop statement conditions. This can cause side effects. Assignments in if statements are acceptable where the declaration is also present and there are no other conditions. Correct if (<a class="el" href="classPlotView.html" title="An plot view viewing a Curves model. ">PlotView</a> *view = window-&gt;activeView()) { ... }</p>
<p>Incorrect if ((bytesRead = connection.read()) &gt; 0) { ... }</p>
<h1>Structural Guidelines </h1>
<p>One header file per class, structure, enumeration.* In general, each code construct should have it's own header file, named after the contained construct. While this creates more files, it makes it easier to locate class definitions and reduces include file overhead for enumerations. Exceptions are allowed for collections of simple, related definitions which are unlikely to change often, such as in <code><a class="el" href="plotexpressionarithmetic_8h_source.html">plotexpressionarithmetic.h</a></code> </p>
<p>Use forward declarations.* Always use forward declarations where possible. Implementation details should be hidden as much as possible. This greatly improves compile times especially as a code base grows. This means that aggregated pointer members are preferred to non-pointer members for complex types.</p>
<p>Limit includes.* Strive to include the minimal number of headers. Excess include statements lead to excessive build times. This comes about both due to increased file dependencies and increased disk IO in large projects.</p>
<p>Order includes.* Order include statements by library first, then alphabetically. Include most local library files first and system headers last. Thus, files in the same directory should be include first, the closely related library headers graduated to most distant libraries, where system headers are considered the most distance. Each library block should be separated by a blank line.</p>
<p>In a header file, the first included header should always be the configuration file for the current library and each library should have such a configuration header.</p>
<p>System headers should not be included in header files, only in source files. This includes stl headers. C headers such as &lt;cstdef&gt; and &lt;cinttypes&gt; are accepted in includes in header files as they define commonly used types such as <code>size_t</code> (when not a built in type) and various sized integers.</p>
<p>This is designed to promote local types first as these are generally the most pertinent to the current source. It also serves to avoid troublesome coding styles from interfering with local definitions. Examples of troublesome coding styles are header files containing using namespace statements and the Windows API use of the preprocessor to select between ASCII and Unicode function implementations. These can ambiguate local declarations.</p>
<p>using namespace statements must not appear in header files.* Head files with using namespace statements generally result in unintended ambiguities in dependent files. These can be very difficult to avoid without modifying the offending header file. Thus using namespace statements are only for source files.</p>
<p>Maintain <code>const</code> correctness.* Const correctness is an important part of building robust code and is difficult to retrofit. Guidelines for maintaining const correctness are:</p><ul>
<li>Prefer const read accessor methods.</li>
<li>Provide both const and non-const read accessors where required.</li>
<li><p class="startli">Pass complex types and large POD types by constant reference. Avoids unnecessary construction/destruction and stack allocation.</p>
<p class="startli">Limit use of templates.* Templates are a useful programming tool for defining algorithms independently of specific types. However, overuse of template programming has several drawbacks:</p>
</li>
</ul>
<ol type="1">
<li>Overuse of templates leads to obfuscation.</li>
<li>Errors required greater interpretation.</li>
<li>Increased compilation time.</li>
</ol>
<p>Techniques such as template meta programming, while powerful, are esoteric and require a good understanding of template and compilers. Compiler errors generated from misuse of templates are generally more difficult to interpret than other compiler errors.</p>
<p>Lazy instantiation of templates leads to increased work for the compiler. While the overhead minimal for simple template types, significant come from using many template types, dependent headers, partial specialisations. Different compilers have different overheads so the potential overheads may not be readily apparent.</p>
<p>Shared library exports must have minimal or no dependencies.* Robust and reliable shared library APIs are a minefield, especially when dealing with with multiple platforms. DLL hell, is well recognised on Windows platforms, but Unix based platforms are not immune to share library issues. A full discussion of these issues is well beyond the scope of this documentation. When exporting shared library symbols;</p><ul>
<li>Use pure virtual interface or the <em>pimple</em> paradigm. Factories are a good way of instantiating concrete implementations.</li>
<li>Use only built in types. This includes avoiding <code>stl</code> types as there is no guarantee that the user will include the same stl implementation, in which case class sizes and member offsets may change.</li>
<li>All memory allocation and deallocation must be hidden behind the exported API. A consumer library may be linking a different runtime which uses different a different resource allocation system.</li>
<li>Avoid <code>inline</code> methods on exported types.</li>
</ul>
<p>Interestingly, recent versions of Visual Studio provided additional compiler warnings about potential dangers surrounding exporting shared library symbols.</p>
<p>Hide implementation details.* This follows on from using forward declarations and from shared library considerations.</p>
<p>Use the same function order in header and source files.* The order of declarations in a header file should be matched in the source file. This aids in navigating between the two files.</p>
<p>Two blank lines between function implementations.* This creates better visual separation between scopes.</p>
<p>Order class scopes : public, protected then private.* This keeps order promotes increasing detail towards the end of the file. A reader can skim the just top of the file, knowing the all of the public API is covered and stop once the public scope is terminated.</p>
<p>Non-public member variables at the end of classes.* Member variables appear the the end of the class declarations. This makes it straight forward to find all the member variables. Public member variables should not be used, with the exception of public constants, which should appear at the top of the class.</p>
<p>Member variables ordered by size.* Order member variables by size (as in <code>sizeof</code>), largest to smallest. This can aid in packing and alignment. This rule has some leniency for who understand alignment and packing.</p>
<p>Constructors initialise all members, in order.* Always initialise all member variables when a constructor is provided. Initialisation order should match the declaration order. This makes it easier to see find omitted initialisations.</p>
<h1>Documentation Guidelines </h1>
<p>Use Doxygen style commenting.* All classes and members should be documented using Doxygen style comments. The preferred commenting structure is to use the triple slash pattern "///". Member variables may be described using the back reference pattern "///&lt;" where the documentation comment is short.</p>
<p>Use in-code documentation.* In code documentation should be used. Code is not "self-documenting." Code requires analysis and interpretation and cannot identify justifications, intent or authoring assumptions. Always consider the following question; "Will I understand this code after a month of not touching it?" "Will I think it's rubbish?"</p>
<p>Use code documentation to identify the "why?" of the code. Highlight justifications, intent, assumptions and boundary conditions.</p>
<p>Document intent.* Class and function documentation should describe the intent of the construct. A class overview should identify the general capabilities then focus on the most commonly used operations of the class. Defining intended usage may be appropriate in cases where specific calls sequences are expected.</p>
<p>Specific implementation details are generally not required as the implementation may change while intent should remain unchanging.</p>
<p>Document assumptions.* Provide information about any assumptions made. For example, ordered call sequences, initialisation order or range limitations. For example, document that null values are not accepted as this is an assumption made by the underlying code. Assumptions also relate to undefined behaviour</p>
<p>Document error and boundary cases.* Highlight where error cases are handled vs. where undefined behaviour may ensue. For example, identify whether null pointer values are handled. Similarly, identify what occurs when out of range values are provided.</p>
<p>Document ranges.* Identify acceptable ranges for parameter values where this may not be immediately apparent. Use range notation: square brackets denote closed intervals (inclusive), while open brackets are for open intervals (exclusive).</p>
<p>Document units.* Consider the declaration and documentation below. class Container { public: ...</p>
<p>/ Gets the size. unsigned size() const;</p>
<p>... }; This is a poor comment for two reasons:</p><ol type="1">
<li>It adds nothing which cannot be gleamed from the function name.</li>
<li><p class="startli">It does not adequately describe how the size is measured (no units). This comment raises questions which cannot be answered without looking at the implementation or empirical testing. Is the size given in bytes or elements? Does the size refer to the</p>
<p class="startli">Document accessor functions.* Even though the functionality of read and write accessor methods may be readily apparent, accessors must still be documented. Either the read or write accessor should describe the semantics of the underlying member variable. The bulk of the documentation belongs with whichever of the read or write function is more pertinent to class usage (which is more important to the user?).</p>
</li>
</ol>
<p>Simple accessor documentation may be somewhat repetitive, but it should add information regarding units and assumptions as described above. Do not assume that usage is self-evident.</p>
<p>Member variable documentation vs. accessor documentation.* Accessor and member variable documentation may overlap. Member variables with accessor methods need only a terse documentation comment, unless internal assumptions differ from the public assumptions.</p>
<h1>Naming Conventions </h1>
<p>Header files have a ".h" suffix.*</p>
<p>Source files have a ".cpp" suffix.*</p>
<p>Use camel case for variable and type declarations.* All declarations are in camelCase capitalising the first letter of each word. The leading character may or may not be capitalised depending on the declaration type. See below.</p>
<p>Type declarations and constant variable declarations begin with a capital letter.* Class, structure, enumeration and constant declarations begin with a capital letter.</p>
<p>Only well known acronyms and abbreviations should be used.* Acronyms and abbreviations in variable names should only be used if they are well known. Network acronyms such as TCP or UDP and abbreviations such as Msg for message are well understood and may be used. Abbreviating local names is confusing and to be avoided. For sample abbreviating "MyTcpConnection" to mtc is ill defined and to be avoided.</p>
<p>All names are descriptive.* All variable, function and type names are to be descriptive, based on the intended usage. Using terse variable names simply to avoid typing is lazy. Single letter variables, or abbreviated names are to be avoided, except in well known use cases such as using 'i', 'j' and 'iter' for loop count iteration.</p>
<p>Accessor methods are named after the accessed variable.* A read accessor is named after a variable, while the write accessor is prefixed by 'set' and the first letter of the accessed variable is capitalised. Examples are below.</p>
<table class="doxtable">
<tr>
<th>Variable </th><th>Read Accessor </th><th>Write Accessor  </th></tr>
<tr>
<td><code>_count</code> </td><td><code>count()</code> </td><td><code>setCount()</code> </td></tr>
<tr>
<td><code>_plot</code> </td><td><code>plot()</code> </td><td><code>setPlot()</code> </td></tr>
<tr>
<td><code>_timeColumn</code> </td><td><code>timeColumn()</code> </td><td><code>setTimeColumn()</code> </td></tr>
<tr>
<td><code>_fullName</code> </td><td><code>fullName()</code> </td><td><code>setFullName()</code> </td></tr>
</table>
<p>Imperative function names with identifiable subject.* Member functions which do something should include an imperative verb to describe the processing performed and should identify the subject of the operation. Here 'subject' is defined in grammatical terms and refers to the target of the verb. Member functions may omit the subject when the operation targets the object itself. The combination of verb and subject helps define the operation semantics.</p>
<p>Read accessor functions and commonly used and well understood paradigms are accepted, such as using <code>size()</code> for the number of elements in a container. However, note the documentation style guides for such declarations.</p>
<p>Examples:</p>
<table class="doxtable">
<tr>
<th>Function Name </th><th>Imperative Verb </th><th>Subject (noun)  </th></tr>
<tr>
<td><code>setTimeScale()</code> </td><td>set </td><td>time scale </td></tr>
<tr>
<td><code>parseColour()</code> </td><td>parse </td><td>colour </td></tr>
<tr>
<td><code>calculateSampleRate()</code> </td><td>calculate </td><td>sample rate </td></tr>
<tr>
<td><code>PlotFile::loadFile()</code> </td><td>load </td><td>plot file </td></tr>
<tr>
<td><code><a class="el" href="classRealTimeTcpConnection.html#ae518bf02ef66f80e8c3b27c6c4d9f5ad" title="Open a TCP connection to the indicated address and port. ">RealTimeTcpConnection::open()</a></code> </td><td>open </td><td>TCP connection </td></tr>
</table>
<p>Non-public member variables are prefixed with a single underscore '_'.* This helps distinguish member variables from local and parameter declarations. By contrast, Hungarian notation tends to be cumbersome.</p>
<p>Acronyms of three letters or more only have the first letter capitalised.* Acronym in type and variable declarations have a leading capital letter, then are lower case. Two letter acronyms may be all caps. The leading letter may be lower case when it is the first letter of a variable declaration. Examples below.</p><ul>
<li><code>class RTPlot</code> - two letter acronym, all caps</li>
<li><code>class <a class="el" href="classRealTimeTcpConnection.html" title="A RealTimeSource which reads from a TCP socket. ">RealTimeTcpConnection</a></code> - Type TCP three letter acronym.</li>
<li><code>Socket *tcpSocket</code> - TCP used at the start of a variable declaration, first letter lower case.</li>
<li><p class="startli"><code>Socket *socketTcp</code> - TCP used later in a variable declaration.</p>
<p class="startli">Enumeration declarations.* Global namespace <code>enum</code> declarations must be unambiguously named to avoid potential naming clashes. The general recommendation is to use prefix enumeration members with an acronym derived from the the enumeration name. This overrides the acronym conversions discussed elsewhere in this document. Scoped enumerations are free to skip any prefix as the scope itself defines the context. Correct enum GroupId { GID_None = -1, GID_Zoom = 0, GID_Tool, GID_Count };</p>
<p class="startli">class <a class="el" href="classPlotView.html" title="An plot view viewing a Curves model. ">PlotView</a> { public: enum ToolMode { MultiTool, PanTool, ZoomTool }; };</p>
</li>
</ul>
<p>Incorrect enum GroupId { None = -1, Zoom = 0, Tool, Count };</p>
<h1>Other Considerations </h1>
<p>Zero compiler warnings.* Compiler warnings often expose potential issues and should always be addressed. While some warnings seem spurious, too many compiler warnings create noise in the compiler output and important warnings are lost amongst the clutter.</p>
<p>Having said that, zero warnings can be difficult when developing cross-platform code and compiling using different compilers and some warnings are difficult to eliminate. For example, Microsoft compilers generate security warnings for standard C functions and are not always easily eliminated. Similarly, Apple's Clang tends to generate warnings about logical operator precedence which can be considered spurious as the precedence is well defined. Similarly the Clang warnings for not using the C++11 override keyword may be spurious unless the project was started from with full C++11 support.</p>
<p>Always address compiler warnings before moving on to keep the noise to a minimum. Disabling warnings on issues similar to those noted above is reasonable. Disabling type conversion warnings is <em>not</em>.</p>
<p>Checkin messages.* Messages on checking to source control must be meaningful, starting with a one line summary of the changes. After that, detail the changes being made. Someone will read the checkin message at some point. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
