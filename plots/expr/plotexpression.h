//
// author Kazys Stepanas
//
// Copyright (c) CSIRO 2013
//
#ifndef __PLOTEXPRESSION_H_
#define __PLOTEXPRESSION_H_

#include "plotsconfig.h"

#include "plotexpressionbinddomain.h"

#include <QList>
#include <QString>

class PlotInstance;
class PlotBindingTracker;
class QwtPointSeriesData;

/// A @c PlotExpression represents an operation in a plot equation.
/// Derivations implement specific operations such as sampling a curve,
/// summing two curve, etc.
///
/// A @c PlotExpression may represent a single operation, or it may combine
/// multiple expressions, forming an expression tree. New plots are generated
/// based on existing curves using a @c PlotExpression root expression.
///
/// Each expression is given the change to generate new curves by the following
/// sequence of operations:
/// - For each curve source file:
///   - Invoke @p bind() to validate expression generation for this source file.
///   - Generate a new curve for each successfull @c bind()
///   - Iterate the sample range generated by the @c PlotExpressionBindInfo from @c bind()
///     - Call @c sample() for each time value.
///   - Cleanup by calling @c unbind()
///   - Attempt next binding
///
/// A successfull call to @c bind() defines the sample range and sample step for
/// the generated curve, as defined by @c PlotExpressionBindInfo. This allows
/// calls to @c sample() until @c unbind() is called.
///
/// Note that an expression may be able to bind to multiple curves in the group
/// passed to @c bind(). For example, given the set of curves [ X_1, X_3, X_4, Y_1, Y_2 ],
/// the regular expression r'X_[0-9]' matches the first three curves. Implementations
/// of the @c bind() are free to match only the first item, however, in some cases
/// such as the regular expression example, it is desirable to bind and generate each
/// viable curve in turn.
///
/// The @c bind() method supports repeated bindings via a @c MultiBindingTracker
/// object. A @c bind() implementation may optionally set a single marker value to
/// the @c MultiBindingTracker and return @c BoundMaybeMore. The return value
/// preempts a repeated call to @c bind() during which the expression may check the
/// existing marker value and resume binding with a new curve. The simplest way
/// to manage the marker value is to use it as the index of the last successfully
/// bound curve.
///
/// Some expression trees may support multiple bindings on different parts of the
/// tree. Consider the following expression: r'X_[0-9]' + r'Y_[0-9]'. An
/// exhaustive binding on the curve set defined above should result in six bindings,
/// as all X_ and Y_ curves are summed against each other. Each @c PlotExpression
/// can maintain its own marker, but a marker must be removed once the associated
/// binding fails, or cannot yield further success. That is, the Y marker must be
/// remove once Y_2 is bound as this is the last viable match of the Y expression.
/// At the same time, the X marker must be held to a constant value so long as
/// new Y values are successfully bound. @c MultiBindingTracker also tracks
/// a hold status for an expression, implying it should return bind the same result
/// as the last successful binding.
///
/// A viable binding sequence for the example above may be:
/// -# Bind X_1, set X marker to 0 (index of X_1).
/// -# Bind Y_1, set Y marker to 3 (index of Y_1).
/// -# Complete expression binding.
/// -# Hold X_1 binding, bind Y_2, clear Y marker
/// -# Complete expression binding.
/// -# Bind X_3, set X marker to 1.
/// -# Bind Y_1, set Y marker to 3 (index of Y_1).
/// -# ...
/// -# Bind X_4, set X marker to 2.
/// -# ...
/// -# Hold X_4 binding, bind Y_2, clear Y marker.
/// -# Complete expression binding.
/// -# Attempt to bind new X, failing to do so, clear X marker.
///
/// Derivations must implement the following methods:
/// - @c sample() - Generate a sample at the requested time.
/// - @c bind() - Initialise sampling of the expression on the given operands.
/// - @c unbind() - (Optional) Clean up sampling state.
/// - @c clone() - Create a deep clone of the @c PlotExpression.
/// - @c stringExpression() - Reverse engineer the @c PlotExpression back to a
///   parseable string form.
class PlotExpression
{
public:
  /// Empty constructor.
  PlotExpression();
  /// Empty, virtual destructor.
  virtual ~PlotExpression();

  /// Called to generate a sample at @p sampleTime.
  ///
  /// The @c sample() call may provide an immediate result or call through to
  /// an expression tree to determine the resulting sample.
  ///
  /// This method may only be called after a successfull call to @c bind(),
  /// or the results are undefined.
  ///
  /// @param sampleTime The time to sample the expression at.
  /// @return The calculated sample at @p sampleTime.
  virtual double sample(double sampleTime) const = 0;

  /// Attempts to binds the @c PlotExpression to sample the given @p curves.
  ///
  /// The @c bind() implementations must first check if the @c PlotExpression can
  /// be evaluated for the given set of @c PlotInstance curve objects. For example,
  /// this may involve checking if a curve matching of a particular name exists.
  /// If all requirements are met, then implementation must prepare for sampling by:
  /// -# Storing relevant @c PlotInstance curve objects for sampling.
  /// -# Define the sampling domain in @p info.
  ///
  /// Calls to @c bind() are expected to be followed by @c sample() calls ending with
  /// a call to @c unbind().
  ///
  /// @param curves The set of existing curves available for sampling. These are the curves
  ///   which were loaded from the source named @p sourceFile.
  /// @param bindTracker Tracks the last binding on a per expression basis.
  /// @param[out] domain To be populated with bound domain details if a successful binding can be
  ///   made.
  /// @param repeatLastBinding True to request that the function rebind whatever it bound
  ///   last time it was called, according to the @p bindTracker. Bind the first possibility
  ///   if there is no such last binding.
  /// @return True if binding is successful, @p info is valid and sampling can occur.
  ///   False if the expression cannot be resolved in the context of the given @p curves.
  virtual BindResult bind(const QList<PlotInstance *> &curves, PlotBindingTracker &bindTracker,
                          PlotExpressionBindDomain &domain, bool repeatLastBinding = false) = 0;

  /// Unbinds the sampling state once sampling has completed.
  ///
  /// Implementation is only required if sampling state clean up is required.
  virtual void unbind() {}

  /// Performs a deep clone of the @c PlotExpression.
  /// @return A clone of the expression.
  virtual PlotExpression *clone() const = 0;

  /// Converts the @c PlotExpression into a parseable string form.
  /// @return The string representation of the expression.
  inline QString toString() const { return stringExpression(); }

  /// Is the curve generated with explicit time values?
  ///
  /// Some expressions, such as slicing, are dependent on explicit time values
  /// and may require regeneration if the time scale, time base or time column
  /// are changed. Such expressions should return true from this method. Tree
  /// expressions should return true if any child expression returns true.
  ///
  /// @return True if the expression generates a curves with explicit time values.
  virtual inline bool explicitTime() const { return false; }

private:
  /// Internal implementation of the string conversion of @c PlotExpression.
  /// This is the implementation of @c toString().
  /// @return The string representation of the expression.
  virtual QString stringExpression() const = 0;
};

#endif // __PLOTEXPRESSION_H_
